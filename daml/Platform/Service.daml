module Platform.Service where

import qualified DA.Set as S
import Platform.Util
import Platform.Types.Common 
import Platform.Types.LA 
import Platform.Types.MI 
import Platform.ModelLA 
import Platform.ModelMI
import Time.Lifecycle.Evolve

template Service
  with
    operator : Party
    host : Party       -- Who will put the house for listing (must be host)
    tenant : Party     -- Who is renting the house
    laKey : LAkey
  where
    signatory operator, host, tenant    -- Market operator and users will need to approve this contract
    
    key (host, tenant) : (Party, Party)  
    maintainer key._1, key._2
  

---- BEGIN ---- MAINTENANCE ISSUES
    nonconsuming choice CreateMI : ContractId MIReport
      with 
        reporter : Party
        house : House
        description : Text
        startingDate : Date --put today date
      controller reporter
      do

        assertMsg ("Creating the MI the reporter is neither tenant nor host.") (reporter == tenant || reporter == host)
        -- Get true number of arbitrators
        (_, LeaseAgreement{leaseTerms, house}) <- fetchByKey @LeaseAgreement laKey 
        let miDetails = MIdetails with nArbitrators = leaseTerms.nArbitrators; house; startingDate; description

        create MIReport with tenant; host; miDetails; arbitrators = S.empty; activeInvitation=False

    nonconsuming choice SubmitAssessment : ContractId Assessment
      with 
        creator : Party
        assessment : AssessmentDetails
        miReportCid : ContractId MIReport
      controller creator
      do
        MIReport{miDetails, arbitrators} <- fetch miReportCid -- can only create assessment if it hasn't already invoked arbitrators
        --assertMsg "Cannot Submit Assessment because arbitrators where already invoked." (arbitrators /= null)
        if creator == tenant then
          create Assessment with creator=tenant; signer=host; miDetails; assessment; miReportCid
        else 
          create Assessment with creator=host; signer=tenant; miDetails; assessment; miReportCid

    nonconsuming choice AcceptAssessment : ContractId MIresultFriendly
      with 
        signer : Party 
        assessmentCid : ContractId Assessment
      controller signer
      do
        exercise assessmentCid SignAssessment with signer

    nonconsuming choice InvokeArbitrators : ContractId InviteArbitrators 
      with
        inviter : Party 
        availableArbitratorsCid : ContractId AvailableArbitrators
        miReportCid : ContractId MIReport
      controller inviter
      do
        MIReport{tenant, host, miDetails, arbitrators, activeInvitation} <- fetchAndArchive miReportCid
        assertMsg "There is already an active Invitation." (not activeInvitation)
        miReportCid <- create MIReport with tenant; host; miDetails; arbitrators; activeInvitation=True
        AvailableArbitrators{arbitrators} <- fetchAndArchive availableArbitratorsCid -- archived by operator
        inviteArbitratorsCid <- create InviteArbitrators with tenant; host; invited=arbitrators; confirmed = S.empty; miDetails; miReportCid -- recently created miReport
        pure inviteArbitratorsCid



---- END ---- MAINTENANCE ISSUES
template Request
  with
    operator : Party
    tenant : Party
    house : House
    leaseTerms : LeaseTerms
  where
    signatory tenant, house.host
    observer operator

    choice Reject : ()
      controller operator      -- operator rejects
      do pure ()

    choice Approve : ContractId Service -- could do a service without automatic payments.
      with 
        evolveId : Text
      controller operator      -- operator approves
      do
        let laKey=LAkey with tenant, house
        (_, Evolve{lifecycler}) <- fetchByKey (operator, evolveId)

        create LeaseAgreement with operator; lifecycler; tenant; house; leaseTerms; paymentsToProcess=leaseTerms.paymentDates
        exerciseByKey @Evolve (operator, evolveId) AddLA with laKey -- necessary operator
        create Service with operator; tenant; host=house.host; laKey = LAkey with tenant; house










