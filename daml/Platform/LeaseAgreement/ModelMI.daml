module Platform.LeaseAgreement.ModelMI where

import DA.Set qualified as S
import Types.Common
import Platform.Types.MI 

template MIReport 
  with
    tenant : Party
    host : Party
    miDetails: MIdetails -- nabritrators bigger then 0
    arbitrators : Parties
  where
    signatory tenant, host 
    observer arbitrators

    key (tenant, host, miDetails) : (Party, Party ,MIdetails)
    maintainer key._1 

    choice SetArbitrators : ContractId MIReport
      with 
        inviter : Party
        arbitrators : Parties
      controller inviter
      do 
        create this with arbitrators 
    
    choice CreateVotation : ContractId Votation
      with 
        visitor : Party
        visitDetails : Text
        assessment : AssessmentDetails
      controller visitor
      do 
        let 
          responsability = (Responsability with 
                              reporterResp=(assessment.responsability.reporterResp/miDetails.nArbitrators), 
                                counterpartResp=assessment.responsability.counterpartResp/miDetails.nArbitrators) 

          result = AssessmentDetails with responsability, cost=assessment.cost, assessmentDate=assessment.assessmentDate, reparationDate=assessment.reparationDate 
          
        create Votation with tenant, host, miDetails; visitor; visitDetails; voters=arbitrators; miReportCid=self; alreadyVoted = S.fromList [visitor]; result


template InviteArbitrators     -- arbitrators recieve notifications when others accept
  with
    inviter : Party 
    invited : Parties       -- Universal arbitrator party doesnt work because if n ot any party could enroll other arbitrators
    confirmed : Parties
    miDetails : MIdetails
    miReportCid : ContractId MIReport
  where
    signatory inviter, confirmed
    observer invited

    choice Accept : ()
      with 
        arbitrator : Party
      controller invited
      do
        assertMsg "The Party is already confirmed in the MI." (S.notMember arbitrator confirmed)
        assertMsg "Impossible to accept because the number of arbitrators has been matched." (S.size confirmed < miDetails.nArbitrators)

        create this with confirmed = S.insert arbitrator confirmed
        pure()
    
    choice ConfirmAttribution : ContractId MIReport
      with 
        inviter : Party
      controller inviter
      do
        assertMsg "The expected number of arbitrators has not been reached." (S.size confirmed == miDetails.nArbitrators)

        exercise miReportCid SetArbitrators with inviter; arbitrators=confirmed



-- before they are allowed to vote the voters must be full
template Votation
  with 
    tenant : Party
    host : Party
    miDetails : MIdetails
    visitor : Party -- can have several
    visitDetails : Text
    voters : Parties  
    miReportCid : ContractId MIReport
    alreadyVoted : Parties
    result : AssessmentDetails
  where 
    signatory alreadyVoted, tenant, host -- Both MI parts agree with the votation
    observer  voters
    

    choice Vote : ContractId Votation 
      with
        voter : Party
        vote : Responsability
      controller voter
        do
          assert (S.member voter (toVote this))
          let newReporterResp = result.responsability.reporterResp + vote.reporterResp / (S.size voters)
              newCounterpartResp = result.responsability.counterpartResp + vote.counterpartResp / (S.size voters)
              responsability = Responsability with reporterResp=newReporterResp, counterpartResp=newCounterpartResp

              newResult = AssessmentDetails with responsability, cost=result.cost, assessmentDate=result.assessmentDate, reparationDate=result.reparationDate 
          
          create Votation with tenant; host; miDetails; visitor; visitDetails; voters; miReportCid; alreadyVoted = S.insert voter voters; result = newResult

    choice FinalizeVotation : ContractId MIresultArbitrators
      with 
        finalizer : Party
      controller finalizer
      do
        assertMsg "Tried to finalize votation with out all votes completed." (alreadyVoted==voters)
        archive miReportCid
        create MIresultArbitrators with tenant; host; miDetails; arbitrators=voters; visitor; visitDetails; assessment=result


toVote : Votation -> Parties
toVote Votation {alreadyVoted, voters} = S.difference voters alreadyVoted







template Assessment
  with 
    creator :  Party
    signer : Party
    assessment : AssessmentDetails
    miDetails : MIdetails
  where 
    signatory creator
    observer  signer
    

    choice SignAssessment : ContractId MIresultFriendly 
      with
        signer : Party
      controller signer
        do
          create MIresultFriendly with assessmentCreator=creator; assessmentSigner=signer; miDetails; assessment





template MIresultArbitrators
  with 
    tenant : Party
    host : Party
    miDetails : MIdetails
    arbitrators : Parties
    visitor : Party
    visitDetails : Text
    assessment : AssessmentDetails 
  where 
    signatory arbitrators
    observer tenant, host



template MIresultFriendly
  with 
    assessmentCreator : Party
    assessmentSigner : Party
    miDetails : MIdetails
    assessment : AssessmentDetails 
  where
    signatory assessmentCreator, assessmentSigner
