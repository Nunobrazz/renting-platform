module Platform.LeaseAgreement.ModelMI where

import DA.Set qualified as S
import Types.Common
import Platform.Types.MI 

import Platform.Util

template MIReport 
  with
    tenant : Party
    host : Party
    miDetails: MIdetails -- nabritrators bigger then 0
    arbitrators : Parties
  where
    signatory tenant, host 
    observer arbitrators

    key (tenant, host, miDetails) : (Party, Party ,MIdetails)
    maintainer key._1 

    choice SetArbitrators : ContractId MIReport
      with 
        inviter : Party
        arbitrators : Parties
      controller inviter
      do 
        create this with arbitrators 
    

    nonconsuming choice CreateVotation : ContractId Votation
      with 
        visitor : Party
        visitDetails : Text
        vote : Responsability
        cost : Int
        assessmentDate : Date
        reparationDate : Date
      controller visitor
      do           
        create Votation with tenant, host, miDetails; visitor; visitDetails; voters=arbitrators; miReportCid=self; assessmentDate;reparationDate;cost; alreadyVoted = S.fromList [visitor]; votes = [vote]





template InviteArbitrators     -- arbitrators recieve notifications when others accept
  with
    inviter : Party 
    invited : Parties       -- Universal arbitrator party doesnt work because if n ot any party could enroll other arbitrators
    confirmed : Parties
    miDetails : MIdetails
    miReportCid : ContractId MIReport
  where
    signatory inviter, confirmed
    observer invited

    choice Accept : ContractId InviteArbitrators
      with 
        arbitrator : Party
      controller arbitrator
      do
        assertMsg "The Party is already confirmed in the MI." (S.notMember arbitrator confirmed)
        assertMsg "Impossible to accept because the number of arbitrators has been matched." (S.size confirmed < miDetails.nArbitrators)

        create this with confirmed = S.insert arbitrator confirmed
    
    choice ConfirmAttribution : ContractId MIReport
      with 
        inviter : Party
      controller inviter
      do
        assertMsg "The expected number of arbitrators has not been reached." (S.size confirmed == miDetails.nArbitrators)
        exercise miReportCid SetArbitrators with inviter; arbitrators=confirmed



-- before they are allowed to vote the voters must be full
template Votation
  with 
    tenant : Party
    host : Party
    miDetails : MIdetails
    visitor : Party -- may have several
    visitDetails : Text
    assessmentDate : Date
    reparationDate : Date
    cost: Int 
    voters : Parties  
    miReportCid : ContractId MIReport
    alreadyVoted : Parties 
    votes : [Responsability]
  where 
    signatory alreadyVoted, tenant, host -- Both MI parts agree with the votation
    observer  voters
    

    choice Vote : ContractId Votation 
      with
        voter : Party
        vote : Responsability
      controller voter
        do
          assertMsg "This party already submitted his vote." (S.member voter (toVote this)) 
          create Votation with tenant; host; miDetails; visitor; visitDetails; voters; miReportCid;assessmentDate;reparationDate; cost; alreadyVoted = S.insert voter voters; votes=vote :: votes


    choice FinalizeVotation : ContractId MIresultArbitrators
      with 
        finalizer : Party
      controller finalizer
      do
        assertMsg "Tried to finalize votation with out all votes completed." (alreadyVoted==voters)
        archive miReportCid
        let 
          responsability = doVotesMean votes 
          assessment = AssessmentDetails with responsability; cost; assessmentDate; reparationDate 
        
        create MIresultArbitrators with tenant; host; miDetails; arbitrators=voters; visitor; visitDetails; assessment


toVote : Votation -> Parties
toVote Votation {alreadyVoted, voters} = S.difference voters alreadyVoted







template Assessment
  with 
    creator :  Party
    signer : Party
    assessment : AssessmentDetails
    miDetails : MIdetails
    miReportCid : ContractId MIReport
  where 
    signatory creator
    observer  signer
    --ensure creator /= signer && (((signer == tenant || signer == host) && (creator == tenant || creator == host)))
    choice SignAssessment : ContractId MIresultFriendly 
      with
        signer : Party
      controller signer
        do          
          create MIresultFriendly with assessmentCreator=creator; assessmentSigner=signer; miDetails; assessment
          -- verifcar creator e singer para nao ser o mesmo




template MIresultArbitrators
  with 
    tenant : Party
    host : Party
    miDetails : MIdetails
    arbitrators : Parties
    visitor : Party
    visitDetails : Text
    assessment : AssessmentDetails 
  where 
    signatory arbitrators
    observer tenant, host



template MIresultFriendly
  with 
    assessmentCreator : Party
    assessmentSigner : Party
    miDetails : MIdetails
    assessment : AssessmentDetails 
  where
    signatory assessmentCreator, assessmentSigner
