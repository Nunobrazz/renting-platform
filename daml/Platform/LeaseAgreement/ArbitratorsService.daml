module Platform.LeaseAgreement.ArbitratorsService where

import qualified DA.Set as S
import Interface.Types as Types (Parties, AssessmentDetails(..), Responsability(..), MIkey(..)) 
import Platform.LeaseAgreement.ModelMI qualified as MImodel (MI(..), InviteArbitrators(..), Accept(..), FinalizeInvitation(..), Votation(..), Vote(..), FinalizeVotation(..))




-- Decide if implement like this or as Role


template Service
  with
    operator : Party     
    arbitrators : Parties
  where
    signatory operator    
    observer arbitrators
    

---- BEGIN ---- EDIT SERVICE

    choice AddArbitratorToService : ContractId Service
      with 
        arbitrator : Party
      controller operator
      do
      create this with arbitrators = S.insert arbitrator arbitrators

---- END ---- EDIT SERVICE



---- BEGIN ---- ARBITRATORS ATTRIBUTION

    nonconsuming choice InviteArbitrators : ContractId MImodel.InviteArbitrators
      with 
        miKey : MIkey
      controller operator
      do
        (_, MImodel.MI{nArbitrators}) <- fetchByKey @MImodel.MI miKey -- This fetch maybe is dispensible 
        create MImodel.InviteArbitrators with operator; invited=arbitrators; confirmed=S.empty; miKey; nArbitrators

    nonconsuming choice AcceptMI : ContractId MImodel.InviteArbitrators
      with 
        inviteArbitratorsCid : ContractId MImodel.InviteArbitrators
        arbitrator :  Party
      controller arbitrator
      do
        exercise inviteArbitratorsCid MImodel.Accept with arbitrator

    nonconsuming choice AssignArbitrators : ContractId MImodel.MI
      with 
        inviteArbitratorsCid : ContractId MImodel.InviteArbitrators
      controller operator
      do
        exercise inviteArbitratorsCid MImodel.FinalizeInvitation

---- END ---- ARBITRATORS ATTRIBUTION



---- BEGIN ---- ARBITRATORS VOTATION
    nonconsuming choice CreateVotation : ContractId MImodel.Votation
      with 
        creator : Party
        description : Text
        miKey : MIkey     
        assessment : AssessmentDetails
      controller creator
      do
        (_, MImodel.MI{arbitrators, nArbitrators}) <- fetchByKey @MImodel.MI miKey -- This fetch maybe is dispensible 
        
        let result = AssessmentDetails with responsability = (Responsability with reporterResp=(assessment.responsability.reporterResp/nArbitrators), counterpartResp=assessment.responsability.counterpartResp/nArbitrators), cost=assessment.cost, assessmentDate=assessment.assessmentDate, reparationDate=assessment.reparationDate 
        
        create MImodel.Votation with creator; description; voters=arbitrators; miKey; alreadyVoted = S.fromList [creator]; result

    nonconsuming choice SubmitVote : ContractId MImodel.Votation
      with 
        voter : Party
        vote : Responsability
        votationCid : ContractId MImodel.Votation
      controller voter
      do
        exercise votationCid MImodel.Vote with voter; vote

    nonconsuming choice FinalizeVotation : ContractId MImodel.MI
      with 
        finalizer : Party
        votationCid : ContractId MImodel.Votation
      controller finalizer
      do
        exercise votationCid MImodel.FinalizeVotation with finalizer

    
---- END ---- ARBITRATORS VOTATION








-- the accepts doesnt work beacuse arbitrator cannot exercise choice
template Offer
  with
    operator : Party
    arbitrator : Party
    serviceCid : ContractId Service
  where
    signatory operator
    observer arbitrator

    choice Accept : ContractId Service
      controller arbitrator
      do
        exercise serviceCid AddArbitratorToService with arbitrator

    choice Decline : ()
      controller arbitrator
      do
        return ()




template Request
  with
    arbitrator : Party
    operator : Party
  where
    signatory arbitrator
    observer operator

    choice Approve : ContractId Service
      with 
        serviceCid : ContractId Service
      controller operator
      do
        exercise serviceCid AddArbitratorToService with arbitrator


    choice Reject : ()
      controller operator
      do
        return ()