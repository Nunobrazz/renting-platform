module Time.Payments where

import Daml.Trigger qualified as T
import DA.List
import DA.Date
import DA.Foldable (forA_)
--import Platform.Interface.Types as Types (Id(..)) 
import Platform.LeaseAgreement.ModelLA

-- uma claim so represetna que uma party deve algo a outra party, quão bem tenho de asseguarar que a claim é cumprida ?
-- saber se o objetivo e executar aqui o pagamento basicamente como é feito o pagamento crio um party que é o custody e confirma que a transação foi realizada ?
{--Note that it is the bank that actively creates a DateClockUpdateEvent. This results in more control when to actually process the coupon payment. One could also use LedgerTime, but that could cause problems in some scenarios, for example:

The system is down when the coupon should be processed. Processing it the next day is difficult if ledger time is automatically used, because the date returned from the ledger no longer matches the intended lifecycling date.
A global ledger containing trades from regions in different time zones may require flexibility regarding when, in relation to ledger time, to process coupons and other events.
The coupon payment depends on market data, which the data provider occasionally provides with a delay. Retroactively processing this is simpler if the lifecycler can provide the today date.--}

{-- | HIDE
ruleImpl : Party -> T.TriggerA() ()
ruleImpl ctrl = do
  nowTime <- getTime
  laCids <- T.query @LeaseAgreement
  let nowDate = toDateUTC nowTime
      toProcess = filter (\(laCid, la) -> head la.leaseTerms.paymentDates <= nowDate) laCids
  
  forA_ laCids $ (\(laCid, la) -> do
    --debug (show ctrl <> ": Processing " <> Id la.id)
    T.dedupExercise laCid ProcessPayment with nowDate )


trigger : T.RelTime -> T.Trigger ()
trigger heartbeat =
  T.Trigger with
    initialize = pure ()
    updateState = \_ -> pure ()
    heartbeat = Some heartbeat
    rule = ruleImpl 
    registeredTemplates = T.RegisteredTemplates [T.registeredTemplate @LeaseAgreement]



-- Having a calendar template and when a LA matches the value in calendar we trigger
template Oracle
  with 
    operator : Party  
    oracle : Party
    laKeys : [LAkey]
    id : Id 
  where 
    signatory operator, oracle 
    key POkey with oracle, id : (POkey)
    maintainer key.oracle
 
    -- The verification of the payment date is done here not to interrupt other interactions with the LA-SC
    nonconsuming choice TriggerPayments : ()
      controller oracle
      do 
        nowTime <- getTime       
        let nowDate = toDateUTC nowTime

        forA_ laKeys (\laKey ->
          do 
            
            (_,LeaseAgreement{leaseTerms}) <- fetchByKey @LeaseAgreement laKey

            if (nowDate `elem` leaseTerms.paymentDates) then do
              exerciseByKey @LeaseAgreement laKey ProcessPayment with paymentsOracle=this.oracle; nowDate
              pure()
             
            else pure())

  
    choice AddLA : ContractId Oracle 
      with
        laKey : LAkey
      controller operator
      do
        create this with laKeys = laKey :: laKeys 


--}