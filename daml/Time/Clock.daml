module Time.Clock where 


import DA.Date (addDays)
import Types.Common (Parties)
import DA.List qualified as L
import DA.Set qualified as S



{-- | Event signalling the update of a `DateClock`. 
template DateClockUpdateEvent
  with
    creator : Party
      -- ^ Provider of the event.
    eventDate : Date
      -- ^ The event time.
    --id : Id
      -- ^ Event identifier.
    observers : Parties
      -- ^ The clock's observers.
  where
    signatory creator
    observer observers  
    key (creator, eventDate) : (Party, Date)
    maintainer key._1
--}

-- | Used to keep track of the current date.
template DateClock
  with
    operator : Party

    providers : [Party]
      -- ^ The clock's provider.
    clockDate : Date
      -- ^ The clock's date.
    public : Party
      -- ^ Observers.
    waitingAccept : Parties
  where
    signatory providers, operator
    observer waitingAccept

    -- if a new provider is added it should be the next one to advance
    choice AddProvider : ContractId DateClock
      with 
        newProvider : Party
      controller operator
      do 
        create this with waitingAccept = S.insert newProvider waitingAccept 
    
    choice Accept : ContractId DateClock
      with 
        newProvider : Party
      controller newProvider
      do 
        create this with providers = newProvider :: providers

    nonconsuming choice Advance : ContractId DateClock
        -- ^ Advance time to its next state.
        with
          advancer : Party
        controller advancer
        do
          assertMsg "Tried to advance clock without permission." (advancer == L.head providers)
          moveClock this self 1 advancer  


-- | HIDE
moveClock : DateClock -> ContractId DateClock -> Int -> Party -> Update (ContractId DateClock)

moveClock this@DateClock {clockDate; providers} self offset advancer = do 
  let
    newDate = addDays clockDate offset
    previousCreator = L.last providers
    newProviders = L.tail providers ++ [advancer]
    clock = this with clockDate=newDate; providers = newProviders


  -- atomic
  -- exerciseByKey @DateClockUpdateEvent (previousCreator, clockDate) Archive   -- archive old event


  archive self                                                          -- archive clock
  clockCid <- create clock                                              -- create clock
  {--create DateClockUpdateEvent with                                      -- create event
    creator=advancer
    observers
    eventDate = clock.clockDate
  -- atomic--}

  pure clockCid


